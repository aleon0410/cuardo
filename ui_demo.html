<html> 
<head> 
<title>My first Three.js app</title>


<style>
#layerSelection {
border-radius:5px;
background-color:#cccccc;
padding: 10px;
position:absolute;
left: 20px;
width: 170px;
font-family: "Arial";
}

</style>

</head>
<body>
<div id="layerSelection">
<p>Layers</p>
<div><input type="checkbox" id="checkTerrain" name="layer" value="0" onclick='layerToggle(this);' checked >Terrain</div>
<div><input type="checkbox" id="checkArrond" name="layer" value="1" onclick='layerToggle(this);' checked >Arrondissements</div>
<div><input type="checkbox" id="checkBati" name="layer" value="2" onclick='layerToggle(this);' checked >Bati</div>

<p></p>

<div id="diplayInfo"></div>

</div>
<div id="container"></div>
<script src="thirdparty/three.js/build/three.js"></script> 
<script src="thirdparty/three.js/examples/js/controls/TrackballControls.js"></script>
<script src="thirdparty/three.js/examples/js/Detector.js"></script>
<script src="thirdparty/three.js/examples/js/libs/stats.min.js"></script>
<script src="thirdparty/three.js/examples/js/shaders/CopyShader.js"></script>
<script src="thirdparty/three.js/examples/js/shaders/SSAOShader.js"></script>
<script src="thirdparty/three.js/examples/js/shaders/BokehShader.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/EffectComposer.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/MaskPass.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/RenderPass.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/ShaderPass.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/BokehPass.js"></script>
<script src="thirdparty/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
<script src="thirdparty/three.js/src/extras/GeometryUtils.js"></script>
<script src="thirdparty/three.js/examples/js/ShaderTerrain.js"></script>
<script src="thirdparty/proj4-src.js"></script>
<script src="thirdparty/proj4-srs.js"></script>
<script src="thirdparty/poly2tri.js"></script>
<script src="thirdparty/poly2tri.js"></script>
<script src="thirdparty/clipper.js"></script>
<script src="thirdparty/jquery-2.1.1.js"></script>
<script src="js/ShaderDraping.js"></script>
<script src="js/Terrain.js"></script>
<script src="js/WfsLayer.js"></script>
<script src="js/Tiler.js"></script>
<script src="js/TileLoader.js"></script>
<script src="js/Tile.js"></script>
<script src="js/QuadNode.js"></script>
<script src="js/QuadTree.js"></script>
<script src="js/PlaneGeometry.js"></script>
<script>
inRender = false;
var quadtree;

init();
animate();

function layerToggle(cb) {
  console.log('switch ', +cb.value, cb.checked);
  quadtree.setLayerVisibility( +cb.value, cb.checked );
  render();
}

function init() {
    window.addEventListener( 'resize', onWindowResize, false );

    document.getElementById('checkTerrain').checked = true;
    document.getElementById('checkArrond').checked = true;
    document.getElementById('checkBati').checked = true;

    document.addEventListener( 'mousedown', onDocumentMouseDown, false );

    // camera
    {
        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 100000 );
        //camera.position.y = -10000;
        camera.position.z = 500;
        //camera.position.y = -500;
    }

    // trackball
    {
        controls = new THREE.TrackballControls( camera );
        controls.rotateSpeed = 2.0;
        controls.zoomSpeed = 1.5;
        controls.panSpeed = 1.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        controls.keys = [ 65, 83, 68 ];
        controls.addEventListener( 'change', render );
    }

    // scene
    {
        scene = new THREE.Scene();

        // my tiled ground
        if (true){
            var urlDem = "http://localhost/mapcache?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&WIDTH=256&HEIGHT=256&LAYERS=mnt&STYLES=&FORMAT=image/png&SRS=EPSG:3946&TILED=true&DPI=96&MAP_RESOLUTION=96&FORMAT_OPTIONS=dpi:96&TRANSPARENT=TRUE"
            var urlTex = "http://localhost/mapcache?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&WIDTH=256&HEIGHT=256&LAYERS=ortho&STYLES=&FORMAT=image/png&SRS=EPSG:3946&TILED=true&DPI=96&MAP_RESOLUTION=96&FORMAT_OPTIONS=dpi:96&TRANSPARENT=TRUE"
            var urlBati = "http://localhost/cgi-bin/tinyows.fcgi?SERVICE=WFS&VERSION=1.0.0&REQUEST=GetFeature&typeName=tows:toitures&outputFormat=JSON";
            var urlWfs = "http://localhost/cgi-bin/tinyows.fcgi?SERVICE=WFS&VERSION=1.0.0&REQUEST=GetFeature&typeName=tows:arrondissements&outputFormat=JSON";
            var translation = new THREE.Vector3(-1841548,-5174099,0);
            var terrain = new Terrain(urlDem, urlTex, translation, 32);
            var wfs = new WfsLayer(urlWfs, translation, 32, terrain, {zOffsetPercent:1e-3, draping:true, polygon:{color:0xaa0000, opacity:.3, lineColor:0xff0000, lineWidth:2, wireframe:false}});
            var bati = new WfsLayer(urlBati, translation, 32, terrain, {polygon:{color:0xffffff,  extrude:'hfacade', lineColor:0x00ff00, lineWidth:2}});

            var tiler =  new Tiler([terrain, wfs, bati], translation, 1);

            var size = 100;

            var maxLOD = 1;
            quadtree = new QuadTree( size, maxLOD, tiler );
            scene.add( quadtree );

        }
        

        // lights
        {
            //light = new THREE.PointLight( 0xdddddd );
            light = new THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 2, 1 );
            light.position.set( 1000, 1000, 1000 );

            light.castShadow = true;
            light.shadowCameraVisible = true;
            light.shadowCameraNear = 1000;
            light.shadowCameraFar = 2000;
            light.shadowCameraFov = 20;
            light.shadowDarkness = 0.5;
            light.shadowMapWidth = 1024;
            light.shadowMapHeight = 512;

            scene.add( light );
            scene.add( new THREE.SpotLightHelper( light, 5 ) );

            alight = new THREE.AmbientLight( 0xdddddd );
            scene.add( alight );

        }

    }

    // renderer
    {
        renderer = new THREE.WebGLRenderer( { antialias: false } );
        renderer.setClearColor( 0x222222, 1 );
        renderer.setSize( window.innerWidth, window.innerHeight );

        //renderer.shadowMapEnabled = true;
        //renderer.shadowMapType = THREE.PCFSoftShadowMap;

        // composer and effects
        {
            composer = new THREE.EffectComposer( renderer );
            composer.addPass( new THREE.RenderPass( scene, camera ) );
        }
    }

    // stats
    {
        container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );
        container.style.position = 'absolute';
        container.style.top = '0px';
        container.style.zIndex = -1;

        //var treeView = document.getElementById( 'myTreeView' );
        //treeView.style.top = '0px';
        //treeView.style.zIndex = 2;

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '150px';
        stats.domElement.style.zIndex = 100;
        container.appendChild( stats.domElement );
    }

    // first render to avoid blank screen before interaction
    render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
    controls.handleResize();
    render();
}

function animate() {
    requestAnimationFrame( animate );
    controls.update();
}

function render() {
    if (inRender) {
        // callback here, but a render is already in progress
        return;
    }
    inRender = true;
    scene.updateMatrixWorld();

    scene.traverse( function ( object ) {
        if ( object instanceof QuadTree ) {
            object.update( camera );
        }
    } );

    renderer.render( scene, camera );
    composer.render()
    stats.update();


    // load missing tiles
    TileLoader.instance().load( render );
    inRender = false;
}

function onDocumentMouseDown( event ) {
    event.preventDefault();

    var objects = [];
    scene.traverse( function(obj) {
        if ( obj.userData && obj.userData.faceGidMap ) {
            objects.push( obj );
        }
    });

    // WATCHOUT! the position must be relative to the canvas

    var vector = new THREE.Vector3( ( (event.clientX - container.offsetLeft) / window.innerWidth ) * 2 - 1, 
                                  - ( (event.clientY - container.offsetTop) / window.innerHeight ) * 2 + 1, 0.5 );
    var projector = new THREE.Projector();
    vector = projector.unprojectVector( vector, camera );

    var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

    var intersects = raycaster.intersectObjects( objects );

    document.getElementById('diplayInfo').innerHTML="";
    if ( intersects.length > 0 ) {
        console.log('intersection ',intersects[ 0 ].object.userData.name,' gid', intersects[ 0 ].object.userData.faceGidMap[ intersects[ 0 ].faceIndex ]);
        document.getElementById('diplayInfo').innerHTML="GID = " + intersects[ 0 ].object.userData.faceGidMap[ intersects[ 0 ].faceIndex ];
    }

}
</script>
</body> 
</html>
