<html> 
<head> 
<title>My first Three.js app</title>
<style>canvas { width: 100%; height: 100% }</style> 
<!--script src="jquery-ui-1.11.0/jquery-ui.js"></script>
<link  rel="stylesheet" href="jquery-ui-1.11.0/jquery-ui.theme.css"/>
<link  rel="stylesheet" href="jquery-ui-1.11.0/jquery-ui.structure.css"/-->
</head> 
<body> 
<div id="header"><p id="header_text">hello</p></div>
<div id="container"></div>
<script src="file:///home/vmo/three.js/build/three.js"></script> 
<script src="file:///home/vmo/three.js/examples/js/controls/TrackballControls.js"></script>
<script src="file:///home/vmo/three.js/examples/js/Detector.js"></script>
<script src="file:///home/vmo/three.js/examples/js/libs/stats.min.js"></script>
<script src="file:///home/vmo/three.js/examples/js/shaders/CopyShader.js"></script>
<script src="file:///home/vmo/three.js/examples/js/shaders/SSAOShader.js"></script>
<script src="file:///home/vmo/three.js/examples/js/shaders/BokehShader.js"></script>
<script src="file:///home/vmo/three.js/examples/js/postprocessing/EffectComposer.js"></script>
<script src="file:///home/vmo/three.js/examples/js/postprocessing/MaskPass.js"></script>
<script src="file:///home/vmo/three.js/examples/js/postprocessing/RenderPass.js"></script>
<script src="file:///home/vmo/three.js/examples/js/postprocessing/ShaderPass.js"></script>
<script src="file:///home/vmo/three.js/examples/js/postprocessing/BokehPass.js"></script>
<script src="file:///home/vmo/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
<script src="file:///home/vmo/three.js/src/extras/GeometryUtils.js"></script>
<script src="proj4-src.js"></script>
<script src="proj4-srs.js"></script>
<script src="jquery-2.1.1.js"></script>
<script src="WfsLayer.js"></script>
<script src="poly2tri.js"></script>
<script> 

var container, stats;
var camera, controls, scene, renderer;
var depthMaterial, depthTarget;
var objects = [];
var projector, particleMaterial;
var text;
var headerText;
var EPSILON = 1e-12;

init();
animate();

function repeated(p1, p2) {
    return Math.abs(p1.x - p2.x) < EPSILON &&  Math.abs(p1.y - p2.y) < EPSILON;
}

function collinear(pa, pb, pc) {
    return Math.abs((pa.x - pc.x) * (pb.y - pc.y) - (pa.y - pc.y) * (pb.x - pc.x)) < EPSILON;
}

function init() {
    window.addEventListener( 'resize', onWindowResize, false );

    // mouse click detect object
    {
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'keydown', onDocumentKeyDown, false );
        projector = new THREE.Projector();
    }

    // camera
    {
        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 100000 );
        //camera.position.y = -10000;
        camera.position.z = 10000;
    }

    // trackball
    {
        controls = new THREE.TrackballControls( camera );
        controls.rotateSpeed = 2.0;
        controls.zoomSpeed = 1.5;
        controls.panSpeed = 1.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        controls.keys = [ 65, 83, 68 ];
        controls.addEventListener( 'change', render );
    }

    // WFS test
    {
        var layer = new WfsLayer('http://localhost/cgi-bin/tinyows');
        layer.load();
    }

    // scene
    {
        scene = new THREE.Scene();

        //scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
        // WFS extract geom given extend
        {
            //var extend = [1831540, 5159897, 1859318, 5192652];
            var extend = [1831402.5, 5160390.5, 1856581, 5192156];
            var translation = [-.5*(extend[2]+extend[0]), -.5*(extend[3]+extend[1])];
            //var translation = [0,0];
            console.log('extend ', extend);
            console.log('translation ', translation);

            var url = 'http://localhost/cgi-bin/tinyows?SERVICE=WFS&VERSION=1.1.0&REQUEST=GetFeature&typeName=tows:pos_opposable_posperime_shp&outputFormat=JSON';
            var material =  new THREE.MeshLambertMaterial( { color:0x00ff00, wireframe:true } );
            material.ambient = material.color;
            var geom = new THREE.Geometry();
            var nbInvalid = 0;
            jQuery.ajax(url, {
                success: function(data, textStatus, jqXHR) {
                    var start = new Date().getTime();
                    var nbPoly = 0;
                    var nbPt = 0;
                    //feat = data.features[0];
                    data.features.forEach( function(feat) {
                        feat.geometry.coordinates.forEach( function(poly){
                            nbPoly++;
                            try {
                                var rings = [];
                                poly.forEach( function(ring) {
                                    var r = rings.length;
                                    rings.push([]);
                                    ring.forEach( function(point) {
                                        var pt = new poly2tri.Point(point[0]+translation[0], point[1]+translation[1]);
                                        if ( !rings[r].length ||
                                            !repeated(rings[r][rings[r].length-1], pt) ) {
                                            if ( rings[r].length < 2 ||
                                                !collinear(rings[r][rings[r].length-2], rings[r][rings[r].length-1], pt)) {
                                                rings[r].push(pt);
                                                nbPt++;
                                            }
                                            else {
                                                rings[r][r.length-1] = pt;
                                            }
                                        }
                                    });
                                    if (rings[r].length) rings[r].pop(); // last point is repeated
                                    if (rings[r].length > 2 && collinear( rings[r][rings[r].length-2], rings[r][rings[r].length-1],  rings[r][0])) rings[r].pop();
                                });
                                //console.log('ring 0 has '+rings[0].length+' points');
                                if (!rings.length || !rings[0].length) return;
                                var swctx = new poly2tri.SweepContext(rings[0]);
                                for (var r=1; r<rings.length; r++) {
                                    if (rings[r].length) swctx.addHole(rings[r]);
                                }
                                swctx.triangulate();
                                var triangles = swctx.getTriangles();
                                var i = geom.vertices.length;
                                triangles.forEach(function(t) {
                                    t.getPoints().forEach(function(p) {
                                        geom.vertices.push(new THREE.Vector3(p.x, p.y, 0));
                                    });
                                    geom.faces.push( new THREE.Face3(i, i+1, i+2) );
                                    i += 3;
                                });
                            }
                            catch (err) {
                                nbInvalid++;
                                console.log('poly:', poly);
                                console.log('poly2tri error:', err);
                                points = err.message.replace(new RegExp(".*supported! \\("),'').replace(new RegExp(".*Constraints \\("),'').split(') (');
                                var errgeom = new THREE.Geometry();
                                points.forEach( function(pt) {
                                    pt = pt.replace(')','');
                                    pt = pt.split(';');
                                    console.log('point:', pt);
                                    errgeom.vertices.push(new THREE.Vector3(+pt[0], +pt[1], 0));
                                });
                                var errmesh = new THREE.Line( errgeom, new THREE.LineBasicMaterial({ color:0xff0000, linewidth: 3 }) );
                                scene.add(errmesh);



                                //throw err;
                                var failedgeom = new THREE.Geometry();
                                poly.forEach( function(ring) {
                                    ring.forEach( function(point) {
                                        var pt = [point[0]+translation[0], point[1]+translation[1]];
                                        failedgeom.vertices.push(new THREE.Vector3(pt[0], pt[1], 0));
                                    });
                                });
                                console.log('failed feature triangulation gid='+feat.properties.gid);
                                var failedmaterial = new THREE.LineBasicMaterial({ color:0xffaaaa, linewidth: 1 });
                                var failedmesh = new THREE.Line( failedgeom, failedmaterial/*, THREE.LinePieces*/ );
                                scene.add(failedmesh);
                            //    //var rings = [];
                            //    //var r = 0;
                            //    //poly.forEach( function(ring) {
                            //    //    rings.push([]);
                            //    //    var lastPoint;
                            //    //    ring.forEach( function(point) {
                            //    //        var pt = [point[0]+translation[0], point[1]+translation[1]];
                            //    //        if (lastPoint && (Math.abs(pt[0]-lastPoint[0])> 0.1 
                            //    //                         || Math.abs(pt[1]-lastPoint[1])> 0.1) ) {
                            //    //            rings[r].push(new THREE.Vector3(pt[0], pt[1], 0));
                            //    //            nbPt++;
                            //    //        }
                            //    //        lastPoint = pt;
                            //    //    });
                            //    //    rings[r].pop();
                            //    //    r++;
                            //    //});
                            //    //if (!r) return;
                            //    //var holes = [];
                            //    //for ( var i = 1; i<r; i++ ) {
                            //    //    holes.push( rings[i] );
                            //    //}
                            //    //var faces = THREE.Shape.Utils.triangulateShape( rings[0], holes );
                            //    //var offset = failedgeom.vertices.length;
                            //    //rings.forEach( function(ring){
                            //    //    ring.forEach( function( v ) {
                            //    //        failedgeom.vertices.push( v );
                            //    //    });
                            //    //});
                            //    //console.log('added '+(failedgeom.vertices.length-offset)+' vertices');
                            //    //faces.forEach( function(face) {
                            //    //    face.a += offset;
                            //    //    face.b += offset;
                            //    //    face.c += offset;
                            //    //    failedgeom.faces.push( face );
                            //    //});
                            }
                        });

                    });
                    var end = new Date().getTime();
                    console.log((end-start)/1000.+'sec to triangulate '+nbPoly+' polygons ('+nbPt+' points) with '+nbInvalid+' failed triangulations');

                },
                async:   false,
                dataType: 'json',
                error: function(jqXHR, textStatus, errorThrown) {
                    console.log(textStatus+' :'+errorThrown);
                    throw errorThrown;
                }
            });
            console.log('nb of vtx ', geom.vertices.length );
            console.log('nb of faces ', geom.faces.length );
            geom.computeBoundingBox();
            console.log('bbox ', geom.boundingBox.min, geom.boundingBox.max);
            geom.computeFaceNormals();
            mesh = new THREE.Mesh( geom, material );
            scene.add(mesh);
        }


        // buildings
        {
            var material =  new THREE.MeshLambertMaterial( { color:0xeeeeee} );
            material.ambient = material.color;
            var sz = .5;
            var geometry = new THREE.BoxGeometry( sz, sz, sz );
            var group = geometry;
            for ( var i = 0; i < 50; i ++ ) {
            
                    var mesh = new THREE.Mesh( geometry, material );
                    mesh.position.x = Math.random() * 400 - 200;
                    mesh.position.y = Math.random() * 300 - 150;
                    mesh.scale.z = Math.random() * 10 + 1;
                    mesh.scale.x = Math.random() * 10 + 1;
                    mesh.scale.y = Math.random() * 5 + 1;
                    mesh.rotation.z = Math.random();
                    mesh.position.z = mesh.scale.z*sz/2.;
                    mesh.castShadow = true;
                    //mesh.receiveShadow = true;
                    //THREE.GeometryUtils.merge(group, mesh);
            }
            // var mesh = new THREE.Mesh( group, material );
            // scene.add( group );
        }

        // test line low level creation
        if(0)
        {
            //var poly2tri = require('poly2tri');
            var contour = [
                new poly2tri.Point(100, 100),
                new poly2tri.Point(100, 300),
                new poly2tri.Point(300, 300),
                new poly2tri.Point(300, 100)
            ];
            var swctx = new poly2tri.SweepContext(contour);
            var hole = [
                new poly2tri.Point(200, 200),
                new poly2tri.Point(200, 250),
                new poly2tri.Point(250, 250)
            ];
            swctx.addHole(hole);
            swctx.triangulate();
            var triangles = swctx.getTriangles();
            //triangles.forEach(function(t) {
            //    t.getPoints().forEach(function(p) {
            //        console.log(p.x, p.y);
            //    });
            //    // or t.getPoint(0), t.getPoint(1), t.getPoint(2)
            //});



            var geometry = new THREE.Geometry();
            var material = new THREE.LineBasicMaterial({ color:0xeeffff, linewidth: 3 });
            var nbSeg = 100;
            for (i=0; i<=nbSeg; i++){
                //geometry.vertices.push( new THREE.Vector3(500*Math.cos(i*2*Math.PI/nbSeg), 500*Math.sin(i*2*Math.PI/nbSeg), 100) );
                geometry.vertices.push( new THREE.Vector3(100*i, 100*i, 100*i) );
            }
            mesh = new THREE.Line( geometry, material );
            scene.add(mesh);
        }

        // test custom mesh
        if (false)
        {
            var geom = new THREE.Geometry(); 
            var v1 = new THREE.Vector3(0,0,0);
            var v2 = new THREE.Vector3(50000,50000,0);
            var v3 = new THREE.Vector3(0,50000,0);
            geom.vertices.push(v1);
            geom.vertices.push(v2);
            geom.vertices.push(v3);
            geom.faces.push( new THREE.Face3( 0, 1, 2 ) );

            var material =  new THREE.MeshLambertMaterial( { color:0xff0000} );
            material.ambient = material.color;
            var mesh = new THREE.Mesh( geom, material );
            scene.add(mesh);
        }

        // ground
        if(false)
        {
            var material =  new THREE.MeshLambertMaterial( { color:0x777777, shading: THREE.FlatShading} );
            material.ambient = material.color;
            var plane = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), material);
            plane.position.z = -0.1;
            plane.receiveShadow = true;
            scene.add(plane);
        }

        // tiled ground
        {
            var extend = [-400, -400, 400, 400];
            var lod = new THREE.LOD();
            scene.add( lod );
            var nbLevel = 5;
            for (var level=1; level<=nbLevel; level++) {
                var sqrtNbTiles = Math.pow(2, level);
                var group = new THREE.Object3D();
                var tileSize = (extend[2]-extend[0])/sqrtNbTiles;
                for (var i=0; i<sqrtNbTiles; i++) {
                    for (var j=0; j<sqrtNbTiles; j++) {
                        var grid = new THREE.GridHelper( tileSize/2, tileSize/8 );
                        var color = Math.random()*0xffffff;
                        grid.setColors( color, color );
                        grid.rotation.x = -Math.PI/2;
                        grid.position.x = extend[0] + 0.5*tileSize + i*tileSize;
                        grid.position.y = extend[1] + 0.5*tileSize + j*tileSize;
                        grid.position.z = 5*level;
                        grid.updateMatrix();
                        grid.matrixAutoUpdate = false;
                        grid.visible = false;
                        group.add( grid );
                    }
                }
                lod.addLevel(group, 1000 -level*1000./nbLevel);

            }
            lod.position.x = 0;
            lod.position.y = 0;
            lod.updateMatrix();
            lod.matrixAutoUpdate = false;
        }
        

        //// grid
        //{
        //    var helper = new THREE.GridHelper( 200, 10 );
        //    helper.setColors( 0x0000ff, 0xf0f0f0 );
        //    helper.rotation.x = -Math.PI/2;
        //    scene.add( helper );
        //}

        // lights
        {
            //light = new THREE.PointLight( 0xdddddd );
            light = new THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 2, 1 );
            light.position.set( 1000, 1000, 1000 );

            light.castShadow = true;
            light.shadowCameraVisible = true;
            light.shadowCameraNear = 1000;
            light.shadowCameraFar = 2000;
            light.shadowCameraFov = 20;
            light.shadowDarkness = 0.5;
            light.shadowMapWidth = 1024;
            light.shadowMapHeight = 512;

            scene.add( light );
            scene.add( new THREE.SpotLightHelper( light, 5 ) );

            alight = new THREE.AmbientLight( 0xdddddd );
            scene.add( alight );

        }

        // LOD
        if(false)
        {

            var sz = 10;
            var geometry = new THREE.BoxGeometry( sz, sz, sz );
            for ( var j = 0; j < 10; j ++ ) {
                var material =  new THREE.MeshPhongMaterial( { color:0xee0000} );
                material.ambient = material.color;
                var lod = new THREE.LOD();
                for ( var i = 0; i < 5; i ++ ) {
                    var mesh = new THREE.Mesh( geometry, material );
                    mesh.scale.z = i + 1;
                    mesh.position.z = .5*sz*mesh.scale.z;
                    mesh.updateMatrix();
                    mesh.matrixAutoUpdate = false;
                    lod.addLevel(mesh, i*100);
                }
                lod.position.x = -100+20*j;
                lod.updateMatrix();
                lod.matrixAutoUpdate = false;
                objects.push(lod);
                scene.add( lod );
            }
        }
    }

    // renderer
    {
        renderer = new THREE.WebGLRenderer( { antialias: false } );
        renderer.setClearColor( 0x222222, 1 );
        renderer.setSize( window.innerWidth, window.innerHeight );

        //renderer.shadowMapEnabled = true;
        //renderer.shadowMapType = THREE.PCFSoftShadowMap;

        // composer and effects
        {
            composer = new THREE.EffectComposer( renderer );
            composer.addPass( new THREE.RenderPass( scene, camera ) );
            
            if (false){
            // ssao
            var depthShader = THREE.ShaderLib[ "depthRGBA" ];
            var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
            depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
            depthMaterial.blending = THREE.NoBlending;
            depthTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
            var effect = new THREE.ShaderPass( THREE.SSAOShader );
            effect.uniforms[ 'tDepth' ].value = depthTarget;
            effect.uniforms[ 'size' ].value.set( window.innerWidth, window.innerHeight );
            effect.uniforms[ 'cameraNear' ].value = camera.near;
            effect.uniforms[ 'cameraFar' ].value = camera.far;
            effect.uniforms[ 'lumInfluence' ].value = .9;
            effect.uniforms[ 'aoClamp' ].value = .5;
            composer.addPass( effect );
            
            // depth of field
            var bokehPass = new THREE.BokehPass( scene, camera, {
                focus: .8,
                aperture:	0.008,
                maxblur:	1,
                width:  window.innerWidth,
                height: window.innerHeight
                } );
            bokehPass.renderToScreen = true;
            composer.addPass( bokehPass );
            }
        }
    }

    // stats
    {
        container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '150px';
        stats.domElement.style.zIndex = 100;
        container.appendChild( stats.domElement );
    }

    // first render to avoid blank screen before interaction
    render();
    render(); // for some reason lod needs that second render

}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
    controls.handleResize();
    render();
}

function animate() {
    requestAnimationFrame( animate );
    controls.update();
}

function render() {
    scene.updateMatrixWorld();
    scene.traverse( function ( object ) {
        if ( object instanceof THREE.LOD ) {
            object.update( camera );
            object.objects.forEach( function(obj) {
                    var visible = obj.object.visible;
                    if ( obj.object instanceof THREE.Object3D ) {
                        obj.object.traverse(function(child) {
                                child.visible = visible;});
                    }
            });

        }

    } );


    scene.overrideMaterial = depthMaterial;
    renderer.render( scene, camera, depthTarget );
    scene.overrideMaterial = null;
    composer.render()
    stats.update();
}

function onDocumentKeyDown( event ) {
    if ( event.keyCode == 65 ){ // a pressed
        camera.lookAt(new THREE.Vector3(0,0,0));
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.w = 10000;
        render();
    }
}
function onDocumentMouseDown( event ) {
    event.preventDefault();

    var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, 
                                  - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
    projector.unprojectVector( vector, camera );

    var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

    var intersects = raycaster.intersectObjects( objects );

    if ( intersects.length > 0 ) {

            var text3d = new THREE.TextGeometry( 'face:'+intersects[ 0 ].faceIndex, {
					size: 2,
					height: .1,
					curveSegments: 2,
					font: "helvetiker"
				});

            //text3d.computeBoundingBox();
            var textMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: 0.5 } );
            scene.remove( text );
            text = new THREE.Mesh( text3d, textMaterial );
            text.position = intersects[ 0 ].point;
            scene.add( text );

            // var material =  new THREE.MeshPhongMaterial( { color:0xbb0000 } );
            // var particle = new THREE.Sprite( particleMaterial );
            // particle.position = intersects[ 0 ].point;
            // particle.scale.x = particle.scale.y = 16;
            // scene.add( particle );
            render();
    }
}

</script> 
</body> 
</html>
