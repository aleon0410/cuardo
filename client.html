<html> 
<head> 
<title>FOSS4G demo</title>

<style>
#uiMenu {
border-radius:5px;
background-color:#cccccc;
padding: 10px;
position:absolute;
left: 20px;
font-family: "Arial";
z-index: 99999;
}

.popin{
	display: none;
	background: #fff;
	padding: 20px;
	border: 20px solid #ddd;
	float: left;
	font-size: 1.2em;
	position: fixed;
	top: 50%; left: 50%;
	z-index: 99999;

	-webkit-box-shadow: 0px 0px 20px #000;
	-moz-box-shadow: 0px 0px 20px #000;
	box-shadow: 0px 0px 20px #000;

	-webkit-border-radius: 10px;
	-moz-border-radius: 10px;
	border-radius: 10px;
}
img.btn_close {
	float: right;
	margin: -42px -42px 0 0;
}
</style>

</head> 
<body> 

<div id="uiMenu">
    <p>Layers</p>
    <div id="layerList">
    </div>

    <p></p>

    <p>Tools</p>
    <div id="userActions">
    <input type="checkbox" id="checkAction" onclick='actionToggle(this);'></input>
    <select id="actionlist">
    <option value="0" selected>Identify</option>
    </select> 
    </div>

    <p></p>
    <div id="progressInfo">
    <p>Tiles loaded: <span id="loadingProgressTxt"></span><img id="loadingImg" src="images/loading.gif" style="visibility:hidden"/></p>
    </span><progress value="0" max="0" id="loadingProgressElt" style="display:inline-block;height:8px;" ></progress><br/>
    </span><progress value="0" max="0" id="tilerProgressElt" style="display:inline-block;height:8px;" ></progress>
    </div>

    <div id="displayInfo"></div>
</div>

<div id="popin_window" class="popin"></div>
<div id="container"></div>

<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.min.js"></script> 
<script src="//cdnjs.cloudflare.com/ajax/libs/proj4js/2.2.2/proj4.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/stats.js/r11/Stats.js"></script>
<!--script src="thirdparty/three.js/build/three.js"></script--> 
<!--script src="thirdparty/three.js/examples/js/controls/TrackballControls.js"></script-->
<!--script src="thirdparty/three.js/examples/js/Detector.js"></script-->
<!--script src="thirdparty/three.js/examples/js/libs/stats.min.js"></script-->
<script src="js/shaders/CopyShader.js"></script>
<script src="js/shaders/SSAOShader.js"></script>
<script src="js/shaders/BokehShader.js"></script>
<script src="js/shaders/FXAAShader.js"></script>
<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/postprocessing/BokehPass.js"></script>
<!--script src="thirdparty/three.js/examples/fonts/helvetiker_regular.typeface.js"></script-->
<!--script src="thirdparty/three.js/src/extras/GeometryUtils.js"></script-->
<!--script src="thirdparty/three.js/examples/js/ShaderTerrain.js"></script-->

<!--script src="thirdparty/proj4-src.js"></script-->
<!--script src="thirdparty/jquery-2.1.1.js"></script-->

<script src="js/proj4-srs.js"></script>
<script src="js/Terrain.js"></script>
<script src="js/WfsLayer.js"></script>
<script src="js/Tiler.js"></script>
<script src="js/TileLoader.js"></script>
<script src="js/QuadNode.js"></script>
<script src="js/QuadTree.js"></script>
<script src="js/Terrain.js"></script>
<script src="js/WfsLayer.js"></script>
<script src="js/WfsTinLayer.js"></script>
<script src="js/Tiler.js"></script>
<script src="js/Tile.js"></script>
<script src="js/PlaneGeometry.js"></script>
<script src="js/GISControls.js"></script>
<script src="js/Symbology.js"></script>
<script src="js/WorkerPool.js"></script>
<script id="configJS"></script>
<script> 

var container, stats;
var camera, controls, scene, renderer;
var depthMaterial, depthTarget;
var quadtree;
var restoreColors = [];

var layerLodList = [];

var renderAsked = true;

// identify actions
var identifyActions = []
var currentTool = -1;

function progressTileLoading( nLoaded, nTotal )
{
    var img = document.getElementById('loadingImg');
    var d = document.getElementById('loadingProgressElt');
    var t = document.getElementById('loadingProgressTxt');
    img.style.visibility = (nLoaded != nTotal ) ? 'visible' : 'hidden';
    d.value = nLoaded;
    d.max = nTotal;
    t.innerHTML = ' ' + nLoaded + '/' + nTotal;
}

function tilerProgress( nLoaded, nTotal )
{
    var d = document.getElementById('tilerProgressElt');
    d.value = nLoaded;
    d.max = nTotal;
}

function notification( text )
{
    var d = document.getElementById('displayInfo');
    d.innerHTML = '<b>' + text + '</b>';
    setTimeout(function(){ d.innerHTML = ''; }, 1000);
}

var keyframes = [];
function onRecord()
{
    var p = controls.getPosition();
    var last = 0;
    if ( keyframes.length ) {
        last = keyframes[keyframes.length-1].dt;
    }
    var dt = prompt("Date (in seconds):", last.toString());
    dt = +(dt);
    keyframes.push( {dt:dt, p:p.p, cam:p.cam} );
    notification('Record added (total:' + keyframes.length + ')');
}

function onReplay()
{
    var fps = 10.0;
    var time_per_frame = 1/fps;

    var positions = [];
    if ( keyframes.length == 0 ) {
        return;
    }
    if ( keyframes.length == 1 ) {
        var p = [keyframes[0]];
        positions.push( {dt:0, p:keyframes[0].p} );
    }
    else {
        for (var i = 1; i < keyframes.length; i++ ) {
            var ki = keyframes[i-1];
            var kj = keyframes[i];
            var n = (kj.dt - ki.dt) / time_per_frame;
            for (var j = 0; j <= n; j++ ) {
                // interpolate
                var alpha = j/n;
                var p = [];
                for ( var k = 0; k < ki.p.length; k++ ) {
                    p.push( kj.p[k] * alpha + ki.p[k] * (1-alpha) );
                }
                positions.push( {p:p, dt:time_per_frame} );
            }
        }
    }

    renderAsked = false;
    controls.animate( positions );
    renderAsked = true;
}

function onSaveAs()
{
    urlContent = "data:application/octet-stream," + encodeURIComponent(JSON.stringify(keyframes));
    window.open(urlContent, 'Records');
}

function onLoad()
{
    var file = document.getElementById('inputFile').files[0];
    if ( file ) {
        console.log(file);
    }
    var f = new FileReader();
    f.onload = function(e) {
        keyframes = JSON.parse( e.target.result );
        notification('Loaded ' + keyframes.length + ' records');
    };
    f.readAsText(file);
}

function onKeyDown(e)
{
    switch ( e.keyCode ) {
        case 82: // R
        this.onRecord();
        break;
        case 80: // P
        this.onReplay();
        break;
        case 83: // S
        this.onSaveAs();
        break;
        case 76: // L
        {
            var html = '<input type="file" id="inputFile"></input><br/><input type="button" value="Load" onClick="onLoad();closePopIn();"/>';
            openPopIn( html );
            break;
        }
        default:
        break;
    }
}

TileLoader.instance().setProgressCallback( progressTileLoading );
TileLoader.instance().setTilerProgressCallback( tilerProgress );

function run()
{
    init();
    animate();
};

function animate()
{
    if ( renderAsked ) {
        render();
        renderAsked = false;
    }
    // call animate @ 60 fps
    requestAnimationFrame(animate);
}

function requestRender()
{
    renderAsked = true;
}

function onerror()
{
    alert("Can't load config, try to call the page with '?demo1'");
};

var d = document.getElementById('configJS');
var configSrc = location.search.substring(1) + '.js';
d.onload = run;
d.onerror = onerror;
d.src = configSrc;

function terrainToggle(cb) {
    scene.traverse( function ( object ) {
        if ( object.userData && object.userData.type == 'terrain' ) {
            object.material.uniforms['visibleMaps'].value[+cb.value] = cb.checked;
        }
    } );
    requestRender();
}
function layerToggle(cb) {
    for ( var i = 0; i < layerLodList.length; i++ ) {
        var lodList = layerLodList[i];
        if ( +cb.value === i ) {
            lodList.forEach(function(l){
                quadtree.setLayerVisibility( l.toString(), cb.checked);
            });
        }
    }
    requestRender();
}

function actionToggle(cb) {
    if (cb.checked){
        currentTool = document.getElementById('actionlist').selectedIndex;
    }
    else {
        currentTool = -1;
    }
}

function init() {

    window.addEventListener( 'resize', onWindowResize, false );
    window.addEventListener( 'keydown', onKeyDown, false );

    document.getElementById('container').addEventListener( 'mousedown', onDocumentMouseDown, false );

    document.getElementById('checkAction').checked = false;

    var config = getConfig();
    
    // camera
    {
        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1000000 );
    }

    // scene
    {
        scene = new THREE.Scene();

        //mesh.castShadow = true;
        //mesh.receiveShadow = true;

        // add controls for each action
        identifyActions = config.actions;
        if (identifyActions) {
            for ( var i = 0; i < config.actions.length; i++ ) {
                var action = config.actions[i];
                var elt = document.getElementById('actionlist');
                var n = document.createElement('option');
                n.value = i+1;
                n.text = action.name;
                elt.add(n);
            }
        }
        
        // layers
        {
            var layers = config.layers;


            //
            // Add HTML visibility controls for each layer
            var tilers = [];
            var idx = 0;
            var d = document.getElementById('layerList');
            var lid = 0;
            layers.forEach( function(l) {
                var idxList = [];
                l.levels.forEach( function(lod) {
                    tilers.push(lod);
                    idxList.push(idx);
                    idx++;
                });
                if ( l.levels[0].visibleTex ){
                    d.innerHTML += '<div><input type="checkbox" name="layer" value="' + lid
                    + '" onclick="layerToggle(this);" checked="true">' + l.name + '</input>';
                    for (var i=0; i<l.levels[0].visibleTex.length; i++){
                        d.innerHTML += '&nbsp;&nbsp;<input type="checkbox" name="layer" value="' + i
                        + '" onclick="terrainToggle(this);" checked="true">' + l.levels[0].urlTex[i].name + '</input><br/>';
                    }
                    d.innerHTML += '</div>';
                    
                }
                else{
                d.innerHTML += '<div><input type="checkbox" id="checkbox' + lid + '" name="layer" value="' + lid
                + '" onclick="layerToggle(this);" checked="true">' + l.name + '</input></div>';

                }
                lid++;
                layerLodList.push( idxList );
            });

            var tiler = new Tiler(tilers, config.translation, 1);

            quadtree = new QuadTree( config.sceneSize, config.maxLOD, tiler );
            quadtree.maxCachedTiles = 256;
            quadtree.visibleLayers.push( 'debug' );
            scene.add( quadtree );

        }

        // sky cube
        {
	    var urls  = [ "images/s_3.png",
                          "images/s_1.png",
                          "images/s_4.png",
                          "images/s_2.png",
                          "images/s_posZ.png",
                          "images/s_negZ.png"];

            var l = config.sceneSize * 10;
	    var skyGeometry = new THREE.BoxGeometry( l, l, l );
	
	    var materialArray = [];
            var stillToLoad = 6;
	    for (var i = 0; i < 6; i++)
		materialArray.push( new THREE.MeshBasicMaterial({
		    map: THREE.ImageUtils.loadTexture( urls[i], null, function() {
                        if (!--stillToLoad) { requestRender(); } }),
		    side: THREE.BackSide
		}));
	    var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
	    var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );

            // add it to the scene
            scene.add( skyBox );
        }

        // grid
        if (0)
        {
            var helper = new THREE.GridHelper( 10000, 1000 );
            helper.setColors( 0x0000ff, 0xf0f0f0 );
            helper.rotation.x = -Math.PI/2;
            scene.add( helper );
        }

        // lights
        {
            //light = new THREE.PointLight( 0xdddddd );
            light = new THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 2, 1 );
            light.position.set( 50000, 50000, 50000 );

            light.castShadow = true;
            light.shadowCameraVisible = true;
            light.shadowCameraNear = 1000;
            light.shadowCameraFar = 2000;
            light.shadowCameraFov = 20;
            light.shadowDarkness = 0.5;
            light.shadowMapWidth = 1024;
            light.shadowMapHeight = 512;

            scene.add( light );
//            scene.add( new THREE.SpotLightHelper( light, 5 ) );

            alight = new THREE.AmbientLight( 0xeeeeee );
            scene.add( alight );

        }
    }

    // trackball
    {
        controls = new THREE.GISControls( camera, null, document.getElementById('container') );
        controls.maxDistance = config.sceneSize * 10;
        controls.rotateSpeed = 2.0;
        controls.zoomSpeed = 1.5;
        controls.panSpeed = 1.8;
        controls.keys = [ 65, 83, 68 ];
        controls.addEventListener( 'change', requestRender );

        var d = (config.sceneSize/2.0) / Math.tan(camera.fov/2.0*Math.PI/180.0);
        controls.distance = d;
        camera.position.z = controls.distance;
        camera.lookAt( new THREE.Vector3(0, 0, 0) );
    }


    // renderer
    {
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setClearColor( 0x222222, 1 );
        renderer.setSize( window.innerWidth, window.innerHeight );

        //renderer.shadowMapEnabled = true;
        //renderer.shadowMapType = THREE.PCFSoftShadowMap;

        // composer and effects
        {
            composer = new THREE.EffectComposer( renderer );
            composer.addPass( new THREE.RenderPass( scene, camera ) );
            
            {
            // ssao
            var depthShader = THREE.ShaderLib[ "depthRGBA" ];
            var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
            depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
            depthMaterial.blending = THREE.NoBlending;
            depthTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
            var effect = new THREE.ShaderPass( THREE.SSAOShader );
            effect.uniforms[ 'tDepth' ].value = depthTarget;
            effect.uniforms[ 'size' ].value.set( window.innerWidth, window.innerHeight );
            effect.uniforms[ 'cameraNear' ].value = camera.near;
            effect.uniforms[ 'cameraFar' ].value = camera.far;
            effect.uniforms[ 'lumInfluence' ].value = .01;
            effect.uniforms[ 'aoClamp' ].value = .8;
            composer.addPass( effect );


            var fxaa = new THREE.ShaderPass( THREE.FXAAShader );
            var dpr = 1;
            if (window.devicePixelRatio !== undefined) {
                dpr = window.devicePixelRatio;
            }
            fxaa.uniforms['resolution'].value.set(1 / (window.innerWidth * dpr), 1 / (window.innerHeight * dpr));
            //fxaa.renderToScreen = true;
            composer.addPass(fxaa);
            
            // depth of field
            var bokehPass = new THREE.BokehPass( scene, camera, {
                focus: .9,
                aperture:	0.005,
                maxblur:	1,
                width:  window.innerWidth,
                height: window.innerHeight
            } );
            bokehPass.renderToScreen = true;
            composer.addPass( bokehPass );

            }
        }
    }

    // stats
    {
        container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );
        container.style.position = 'absolute';
        container.style.top = '0px';
        container.style.left = '0px';
        container.style.zIndex = -1;

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '300px';
        stats.domElement.style.zIndex = 100;
        container.appendChild( stats.domElement );
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
    controls.handleResize();
    requestRender();
}

var lastRender = null;

function render(t) {
    scene.updateMatrixWorld();

    scene.traverse( function ( object ) {
        if ( object instanceof QuadTree ) {
            object.update( camera );
        }
    } );

    scene.overrideMaterial = depthMaterial;
    renderer.render( scene, camera, depthTarget );
    scene.overrideMaterial = null;
    composer.render()
    stats.update();

    // load missing tiles
    TileLoader.instance().load( requestRender );
}

function openPopIn( html, px, py )
{
    var popin = document.getElementById('popin_window');
    var h = '<a href="javascript:closePopIn(this)"><img src="images/close.png" width="32" height="32" class="btn_close" onClick="closePopIn()"/></a>';
    popin.innerHTML = h + html;
    if ((px !== undefined) && (py !== undefined)) {
        popin.style.top = py+'px';
        popin.style.left = px+'px';
    }
    popin.style.display = 'block';
}

function closePopIn()
{
    var elt = document.getElementById('popin_window');
    elt.style.display = 'none';
}

function onAction( layerUrl, gid, actionIdx, position ) {
    var layerName = /typeName=([^&]+)/.exec(layerUrl);

    var q = layerUrl+'&featureId='+layerName[1]+'.'+gid;
    jQuery.ajax(q, {
        success: function(data, textStatus, jqXHR) {
            var props = data.features[0].properties;

            if (actionIdx === 0 ) {
                var html = '<table>';
                for ( var k in props ) {
                    html += '<tr><td>' + k + '</td><td>' + props[k] + "</td></tr>\n";
                }
                html += '</table>';
                openPopIn( html, position ? position.x : undefined, position ? position.y : undefined );
            }
            else {
                var action = identifyActions[actionIdx-1];
                if ( action.url === layerUrl ) {
                    action.action(props);
                }
            }
        },
        async:   true,
        dataType: 'json',
        error: function(jqXHR, textStatus, errorThrown) {
            console.warn(jqXHR + textStatus+' :'+errorThrown);
        }
    });
}

function onDocumentMouseDown( event ) {
    event.preventDefault();
    if ( currentTool == -1 ) {
        return;
    }
    currentTool = document.getElementById('actionlist').selectedIndex;

    // highlight
    restoreColors.forEach(function(r){
            r.obj.geometry.attributes.color.array[r.idx] = r.color.r;
            r.obj.geometry.attributes.color.array[r.idx+1] = r.color.g;
            r.obj.geometry.attributes.color.array[r.idx+2] = r.color.b;
            r.obj.geometry.attributes.color.needsUpdate = true;
        });
    restoreColors = [];

    var objects = [];

    scene.traverse( function(obj) {
        if ( obj.userData && obj.userData.vertexGidMap ) {
            objects.push( obj );
        }
    });

    // WATCHOUT! the position must be relative to the canvas

    var vector = new THREE.Vector3( ( (event.clientX - container.offsetLeft) / window.innerWidth ) * 2 - 1, 
                                  - ( (event.clientY - container.offsetTop) / window.innerHeight ) * 2 + 1, 0.5 );
    var projector = new THREE.Projector();
    vector = projector.unprojectVector( vector, camera );

    var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

    var intersects = raycaster.intersectObjects( objects );

    for (var idx = 0; idx < intersects.length; idx++ ) {
        var object = intersects[ idx ].object;
        if ( !object.visible ) continue;
        var map = object.userData.vertexGidMap;
        var gid = map[ intersects[ idx ].indices[0] ];

        onAction( object.userData.url, gid, currentTool, {x:event.clientX, y:event.clientY} );

        scene.traverse( function(obj) {
            var c = new THREE.Color(0xffff00);
            if ( obj.userData && obj.userData.vertexGidMap && obj.userData.url == object.userData.url) {
                
                for (var i=0, end = obj.geometry.attributes.position.array.length/3; i<end; i++){
                    if ( obj.userData.vertexGidMap[i] == gid ){
                        restoreColors.push({
                            obj: obj,
                            idx: i*3, 
                            color: { 
                                r:obj.geometry.attributes.color.array[i*3], 
                                g:obj.geometry.attributes.color.array[i*3+1], 
                                b:obj.geometry.attributes.color.array[i*3+2]}});
                        obj.geometry.attributes.color.array[i*3] = c.r;
                        obj.geometry.attributes.color.array[i*3+1] = c.g;
                        obj.geometry.attributes.color.array[i*3+2] = c.b;
                        //console.log('changed color of vtx', i )
                           
                           //{geom:obj.geometry, face:obj.geometry.faces[i], color:obj.geometry.faces[i].color});
                       //obj.geometry.faces[i].color = c;
                    }
                }
                obj.geometry.attributes.color.needsUpdate = true;
            }
        });
        break;
    }

    requestRender();
}
</script> 
</body> 
</html>
