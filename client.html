<html> 
<head> 
<title>FOSS4G demo</title>

<style>
#layerSelection {
border-radius:5px;
background-color:#cccccc;
padding: 10px;
position:absolute;
left: 20px;
width: 170px;
font-family: "Arial";
}
</style>

</head> 
<body> 
<div id="layerSelection">
<p>Layers</p>
<div><input type="checkbox" id="checkTerrain" name="layer" value="0" onclick='layerToggle(this);' checked >Terrain</input></div>
<div><input type="checkbox" id="checkArrond" name="layer" value="1" onclick='layerToggle(this);' checked >Arrondissements</input></div>
<div><input type="checkbox" id="checkBati" name="layer" value="2" onclick='layerToggle(this);' checked >Bati</input></div>

<p></p>

<p>Tools</p>
<div><input type="checkbox" id="checkIdentify" onclick='identifyToggle(this);'>Identify feature</input></div>

<p></p>

<div id="diplayInfo"></div>

</div>
<div id="container"></div>

<script src="thirdparty/three.js/build/three.js"></script> 
<script src="thirdparty/three.js/examples/js/controls/TrackballControls.js"></script>
<script src="thirdparty/three.js/examples/js/Detector.js"></script>
<script src="thirdparty/three.js/examples/js/libs/stats.min.js"></script>
<script src="thirdparty/three.js/examples/js/shaders/CopyShader.js"></script>
<script src="thirdparty/three.js/examples/js/shaders/SSAOShader.js"></script>
<script src="thirdparty/three.js/examples/js/shaders/BokehShader.js"></script>
<script src="thirdparty/three.js/examples/js/shaders/FXAAShader.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/EffectComposer.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/MaskPass.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/RenderPass.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/ShaderPass.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/BokehPass.js"></script>
<script src="thirdparty/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
<script src="thirdparty/three.js/src/extras/GeometryUtils.js"></script>
<script src="thirdparty/three.js/examples/js/ShaderTerrain.js"></script>
<script src="thirdparty/proj4-src.js"></script>
<script src="thirdparty/proj4-srs.js"></script>
<script src="thirdparty/jquery-2.1.1.js"></script>
<script src="thirdparty/poly2tri.js"></script>

<script src="js/Terrain.js"></script>
<script src="js/WfsLayer.js"></script>
<script src="js/Tiler.js"></script>
<script src="js/TileLoader.js"></script>
<script src="js/QuadNode.js"></script>
<script src="js/QuadTree.js"></script>
<script src="js/Terrain.js"></script>
<script src="js/WfsLayer.js"></script>
<script src="js/WfsTinLayer.js"></script>
<script src="js/Tiler.js"></script>
<script src="js/Tile.js"></script>
<script src="js/PlaneGeometry.js"></script>
<script src="js/GISControls.js"></script>
<script> 

inRender = false;
var container, stats;
var camera, controls, scene, renderer;
var depthMaterial, depthTarget;
var quadtree;
var restoreColors = [];

init();
render();

function layerToggle(cb) {
    console.log('switch',  +cb.value);
    switch ( +cb.value ){
        case 0:
            quadtree.setLayerVisibility( 0, cb.checked );
            break;
        case 1:
            quadtree.setLayerVisibility( 1, cb.checked );
            break;
        case 2:
            quadtree.setLayerVisibility( 2, cb.checked );
            quadtree.setLayerVisibility( 3, cb.checked );
            quadtree.setLayerVisibility( 4, cb.checked );
            break;

    }
    requestAnimationFrame( render );
}

function identifyToggle(cb) {
    if (cb.checked){
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
    }
    else {
        document.removeEventListener( 'mousedown', onDocumentMouseDown, false );
    }
}

function init() {
    window.addEventListener( 'resize', onWindowResize, false );

    document.getElementById('checkTerrain').checked = true;
    document.getElementById('checkArrond').checked = true;
    document.getElementById('checkBati').checked = true;
    document.getElementById('checkIdentify').checked = false;


    // camera
    {
        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 20000 );
        camera.position.z = 500;
        camera.position.y = -3000;
        camera.lookAt( new THREE.Vector3(0, 0, 200) );
    }

    // trackball
    {
        controls = new THREE.GISControls( camera );
        controls.rotateSpeed = 2.0;
        controls.zoomSpeed = 1.5;
        controls.panSpeed = 1.8;
        controls.keys = [ 65, 83, 68 ];
        // distance to the center
        controls.distance = 10000;
        controls.addEventListener( 'change', function() { requestAnimationFrame(render); } );
    }

    // scene
    {
        scene = new THREE.Scene();

        //mesh.castShadow = true;
        //mesh.receiveShadow = true;

        // layers
        {
	    var domain = document.location.host;
            var urlDem = "http://" + domain + "/mapcache?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&WIDTH=256&HEIGHT=256&LAYERS=mnt&STYLES=&FORMAT=image/png&SRS=EPSG:3946&TILED=true&DPI=96&MAP_RESOLUTION=96&FORMAT_OPTIONS=dpi:96&TRANSPARENT=TRUE"
            var urlTex = "http://" + domain + "/mapcache?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&WIDTH=256&HEIGHT=256&LAYERS=ortho&STYLES=&FORMAT=image/png&SRS=EPSG:3946&TILED=true&DPI=96&MAP_RESOLUTION=96&FORMAT_OPTIONS=dpi:96&TRANSPARENT=TRUE"
            var urlImageBase = "http://" + domain + "/textures/LYON_3_Appearance/";

            var baseUrl = "http://" + domain + "/cgi-bin/tinyows.fcgi?SERVICE=WFS&VERSION=1.0.0&REQUEST=GetFeature&outputFormat=JSON";
            // Lyon 3
            var translation = new THREE.Vector3(-1843818.1,-5175084.2, -150);
            var terrain = new Terrain(urlDem, urlTex, translation, 32);

            var urlArrond = baseUrl+"&typeName=tows:arrondissements";
            var colFun = 
                'function(feat){ '+
                    'switch( +feat.properties.gid ){ '+
                        'case 7: return 0x0000aa; '+
                        'case 9: return 0x00aa00; '+
                    '} ' +
                    'return 0xaaaaaa; '+ 
                '}';
            var arrond = new WfsLayer(urlArrond, translation, 32, terrain, {zOffsetPercent:1e-3, draping:true, polygon:{color:0xffffff, lineColor:0xff0000, lineWidth:2, wireframe:false, colorFun:colFun, opacity:.2}});

            var lod0_url = baseUrl+"&typeName=tows:toitures";
            var lod0 = new WfsLayer(lod0_url, translation, 32, terrain,
                                    {zOffsetPercent:2e-3, zOffset:10, polygon:{color:0xaaaaaa, lineColor:0xffffff, lineWidth:1}}
                                    , [1000,5999] );


            var lod1_url = baseUrl+"&typeName=tows:toitures";
            var lod1 = new WfsLayer(lod1_url, translation, 32, terrain,
                                    {polygon:{color:0xffffff, extrude:'hfacade', colorFun:'function(feat){if (feat.properties.gid%2) return 0xddddff;else return 0xffdddd;}'}}
                                    , [250, 999] );

            var urlTin = baseUrl+"&typeName=tows:textured_citygml";
            var tin = new WfsTinLayer( urlTin, urlImageBase, translation, 32, terrain, [0,249] );

            var tiler = new Tiler([terrain, arrond, lod0, lod1, tin], translation, 1);

            var size = 1500;

            var maxLOD = 3;
            quadtree = new QuadTree( size, maxLOD, tiler );
            scene.add( quadtree );

        }

        // sky cube
        {
	    var urls  = [ "images/s_3.png",
                          "images/s_1.png",
                          "images/s_4.png",
                          "images/s_2.png",
                          "images/s_posZ.png",
                          "images/s_negZ.png"];

	    var skyGeometry = new THREE.BoxGeometry( 10000, 10000, 10000 );
	
	    var materialArray = [];
	    for (var i = 0; i < 6; i++)
		materialArray.push( new THREE.MeshBasicMaterial({
		    map: THREE.ImageUtils.loadTexture( urls[i] ),
		    side: THREE.BackSide
		}));
	    var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
	    var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );

            // add it to the scene
            scene.add( skyBox );
        }

        // grid
        if (1)
        {
            var helper = new THREE.GridHelper( 10000, 1000 );
            helper.setColors( 0x0000ff, 0xf0f0f0 );
            helper.rotation.x = -Math.PI/2;
            scene.add( helper );
        }

        // lights
        {
            //light = new THREE.PointLight( 0xdddddd );
            light = new THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 2, 1 );
            light.position.set( 5000, 5000, 5000 );

            light.castShadow = true;
            light.shadowCameraVisible = true;
            light.shadowCameraNear = 1000;
            light.shadowCameraFar = 2000;
            light.shadowCameraFov = 20;
            light.shadowDarkness = 0.5;
            light.shadowMapWidth = 1024;
            light.shadowMapHeight = 512;

            scene.add( light );
            scene.add( new THREE.SpotLightHelper( light, 5 ) );

            alight = new THREE.AmbientLight( 0xeeeeee );
            scene.add( alight );

        }
    }

    // renderer
    {
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setClearColor( 0x222222, 1 );
        renderer.setSize( window.innerWidth, window.innerHeight );

        //renderer.shadowMapEnabled = true;
        //renderer.shadowMapType = THREE.PCFSoftShadowMap;

        // composer and effects
        {
            composer = new THREE.EffectComposer( renderer );
            composer.addPass( new THREE.RenderPass( scene, camera ) );
            
            {
            // ssao
            var depthShader = THREE.ShaderLib[ "depthRGBA" ];
            var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
            depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
            depthMaterial.blending = THREE.NoBlending;
            depthTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
            var effect = new THREE.ShaderPass( THREE.SSAOShader );
            effect.uniforms[ 'tDepth' ].value = depthTarget;
            effect.uniforms[ 'size' ].value.set( window.innerWidth, window.innerHeight );
            effect.uniforms[ 'cameraNear' ].value = camera.near;
            effect.uniforms[ 'cameraFar' ].value = camera.far;
            effect.uniforms[ 'lumInfluence' ].value = .01;
            effect.uniforms[ 'aoClamp' ].value = .8;
            composer.addPass( effect );
            
            // depth of field
            var bokehPass = new THREE.BokehPass( scene, camera, {
                focus: .9,
                aperture:	0.005,
                maxblur:	1,
                width:  window.innerWidth,
                height: window.innerHeight
            } );
            bokehPass.renderToScreen = true;
            composer.addPass( bokehPass );

            var fxaa = new THREE.ShaderPass( THREE.FXAAShader );
            var dpr = 1;
            if (window.devicePixelRatio !== undefined) {
                dpr = window.devicePixelRatio;
            }
            fxaa.uniforms['resolution'].value.set(1 / (window.innerWidth * dpr), 1 / (window.innerHeight * dpr));
            fxaa.renderToScreen = true;
            composer.addPass(fxaa);
            }
        }
    }

    // stats
    {
        container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );
        container.style.position = 'absolute';
        container.style.top = '0px';
        container.style.left = '0px';
        container.style.zIndex = -1;

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '300px';
        stats.domElement.style.zIndex = 100;
        container.appendChild( stats.domElement );
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
    controls.handleResize();
    requestAnimationFrame( render );
}

var lastRender = null;

function render() {
    if (inRender) {
        // callback here, but a render is already in progress
        return;
    }
    inRender = true;

    scene.updateMatrixWorld();

    scene.traverse( function ( object ) {
        if ( object instanceof QuadTree ) {
            object.update( camera );
        }
    } );

    scene.overrideMaterial = depthMaterial;
    renderer.render( scene, camera, depthTarget );
    scene.overrideMaterial = null;
    composer.render()
    stats.update();

    // load missing tiles
    TileLoader.instance().load( function(){ requestAnimationFrame(render); } );
    inRender = false;
}

function onDocumentMouseDown( event ) {
    event.preventDefault();
    // highlight
    restoreColors.forEach(function(obj){
            obj.face.color = obj.color;
            obj.geom.colorsNeedUpdate = true;
        });
    restoreColors = [];

    var objects = [];
    scene.traverse( function(obj) {
        if ( obj.userData && obj.userData.faceGidMap ) {
            objects.push( obj );
        }
    });

    // WATCHOUT! the position must be relative to the canvas

    var vector = new THREE.Vector3( ( (event.clientX - container.offsetLeft) / window.innerWidth ) * 2 - 1, 
                                  - ( (event.clientY - container.offsetTop) / window.innerHeight ) * 2 + 1, 0.5 );
    var projector = new THREE.Projector();
    vector = projector.unprojectVector( vector, camera );

    var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

    var intersects = raycaster.intersectObjects( objects );

    document.getElementById('diplayInfo').innerHTML="";
    for (var idx = 0; idx < intersects.length; idx++ ) {
        var object = intersects[ idx ].object;
        if ( !object.visible ) continue;
        var map = object.userData.faceGidMap;
        var gid = map[ intersects[ 0 ].faceIndex ];
        console.log('intersection ',object.userData.name,' gid', map[ intersects[ 0 ].faceIndex ]);
        document.getElementById('diplayInfo').innerHTML="GID = " +gid;

        scene.traverse( function(obj) {
            var c = new THREE.Color(0xffff33);
            if ( obj.userData && obj.userData.faceGidMap && obj.userData.url == object.userData.url) {
                for (var i=0; i<obj.geometry.faces.length; i++){
                    if ( obj.userData.faceGidMap[i] == gid ){
                       restoreColors.push( {geom:obj.geometry, face:obj.geometry.faces[i], color:obj.geometry.faces[i].color});
                       obj.geometry.faces[i].color = c;
                    }
                }
                obj.geometry.colorsNeedUpdate = true;
            }
        });
        break;
    }

    requestAnimationFrame( render );
}
</script> 
</body> 
</html>
