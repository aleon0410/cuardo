<html> 
<head> 
<title>Cardano</title>
<link rel="stylesheet" href="client.css" type="text/css">
</head> 
<body> 

<div id="map">

<div id="uiMenu">
    <div id="stats"></div>
    <div id="layerList">Layers</div>
    <p/>
    <div id="progressInfo"></div>
    <p/>
    <div id="tools"></div>
    <p/>
    <div id="displayInfo"></div>
</div>

<div id="popin_window" class="popin"></div>

<div id="container"></div>

<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.min.js"></script> 
<script src="//cdnjs.cloudflare.com/ajax/libs/proj4js/2.2.2/proj4.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/stats.js/r11/Stats.js"></script>
<!--script src="build/cuardo.js"></script-->
<script src="js/cuardo.js"></script>
<script src="js/proj4-srs.js"></script>
<script src="js/TileLoader.js"></script>
<script src="js/PlaneGeometry.js"></script>
<script src="js/shaders/FXAAShader.js"></script>
<script src="js/shaders/BokehShader.js"></script>
<script src="js/shaders/CopyShader.js"></script>
<script src="js/shaders/SSAOShader.js"></script>
<script src="js/WorkerPool.js"></script>
<script src="js/GISControls.js"></script>
<script src="js/postprocessing/BokehPass.js"></script>
<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/WfsTinLayer.js"></script>
<script src="js/Terrain.js"></script>
<script src="js/QuadTree.js"></script>
<script src="js/LayerSet.js"></script>
<script src="js/RasterLayer.js"></script>
<script src="js/Symbology.js"></script>
<script src="js/Tiler.js"></script>
<script src="js/QuadNode.js"></script>
<script src="js/WfsLayer.js"></script>
<script src="js/Tile.js"></script>
<script src="js/RecordReplayControl.js"></script>
<script src="js/ProgressBarControl.js"></script>
<script src="js/FeatureActionControl.js"></script>
<script src="js/LayerVisibilityControl.js"></script>
<script src="js/Popin.js"></script>
<script src="js/Map.js"></script>

<script id="configJS"></script>
<script> 

var mymap;
var recordAndReplay;
var controls;
var progress;
var featureActionControls;
var layerVisibilityControls;

var restoreColors = [];

function notification( text )
{
    var d = document.getElementById('displayInfo');
    d.innerHTML = '<b>' + text + '</b>';
    setTimeout(function(){ d.innerHTML = ''; }, 1000);
}

function run()
{
    init();
    mymap.animate();
};


function onerror()
{
    document.location='client.html?examples/example1';
};


var d = document.getElementById('configJS');
var configSrc = location.search.substring(1) + '.js';
d.onload = run;
d.onerror = onerror;
d.src = configSrc;

function init() {

    var config = getConfig();
    var layers = [];
    config.layers.forEach( function(l) {
        layers.push(l.layer);
    });

    mymap = new cuardo.Map('container', layers, config.sceneSize, config.maxLOD, config.maxCachedTiles);
    console.log("map", mymap);

    mymap.target.addEventListener( 'click', onDocumentMouseDown, false );


    // trackball
    {
        controls = new cuardo.GISControls( mymap.camera, null, mymap.target );
        controls.maxDistance = config.sceneSize * 10;
        controls.rotateSpeed = 2.0;
        controls.zoomSpeed = 1.5;
        controls.panSpeed = 1.8;
        controls.keys = [ 65, 83, 68 ];
        controls.addEventListener( 'change', mymap.requestRender );

        var d = (config.sceneSize/2.0) / Math.tan(mymap.camera.fov/2.0*Math.PI/180.0);
        controls.distance = d;
        mymap.camera.position.z = controls.distance;
        mymap.camera.lookAt( new THREE.Vector3(0, 0, 0) );
    }

    recordAndReplay = new cuardo.RecordReplayControl( controls, notification );
    progress = new cuardo.ProgressBarControl( 'progressInfo', notification);

    // add controls for each action
    if (config.actions) {
        featureActionControls = new cuardo.FeatureActionControl('tools');
        for ( var i = 0; i < config.actions.length; i++ ) {
            var action = config.actions[i];
            featureActionControls.add( action.name, action.action );
        }
    }

    layerVisibilityControls = new cuardo.LayerVisibilityControl('layerList', mymap.requestRender);
    var layers = [];
    config.layers.forEach( function(l) {
        layers.push(l.layer);
        layerVisibilityControls.add( l.name, l.layer );
    });
}


function onDocumentMouseDown( event ) {
    event.preventDefault();

    // highlight
    restoreColors.forEach(function(r){
            r.obj.geometry.attributes.color.array[r.idx] = r.color.r;
            r.obj.geometry.attributes.color.array[r.idx+1] = r.color.g;
            r.obj.geometry.attributes.color.array[r.idx+2] = r.color.b;
            r.obj.geometry.attributes.color.needsUpdate = true;
        });
    restoreColors = [];
    mymap.requestRender();

    if (!featureActionControls || !featureActionControls.isActive()) return;

    var objects = [];

    mymap.scene.traverse( function(obj) {
        if ( obj.userData && obj.userData.vertexGidMap ) {
            objects.push( obj );
        }
    });

    // WATCHOUT! the position must be relative to the canvas

    var vector = new THREE.Vector3( ( (event.clientX - mymap.target.offsetLeft) / mymap.width() ) * 2 - 1, 
                                  - ( (event.clientY - mymap.target.offsetTop) / mep.height() ) * 2 + 1, 0.5 );
    var projector = new THREE.Projector();
    vector = projector.unprojectVector( vector, mymap.camera );

    var raycaster = new THREE.Raycaster( mymap.camera.position, vector.sub( mymap.camera.position ).normalize() );

    var intersects = raycaster.intersectObjects( objects );

    for (var idx = 0; idx < intersects.length; idx++ ) {
        var object = intersects[ idx ].object;
        if ( !object.visible ) continue;
        var map = object.userData.vertexGidMap;
        var gid = map[ intersects[ idx ].indices[0] ];

        //onAction( object.userData.layer, gid, currentTool, {x:event.clientX, y:event.clientY} );
        if (!featureActionControls.exec(object.userData.layer, gid,  {x:event.clientX, y:event.clientY}) ) break;

        mymap.scene.traverse( function(obj) {
            var c = new THREE.Color(0xffff00);
            if ( obj.userData && obj.userData.vertexGidMap && obj.userData.layer.url == object.userData.layer.url) {
                
                for (var i=0, end = obj.geometry.attributes.position.array.length/3; i<end; i++){
                    if ( obj.userData.vertexGidMap[i] == gid ){
                        restoreColors.push({
                            obj: obj,
                            idx: i*3, 
                            color: { 
                                r:obj.geometry.attributes.color.array[i*3], 
                                g:obj.geometry.attributes.color.array[i*3+1], 
                                b:obj.geometry.attributes.color.array[i*3+2]}});
                        obj.geometry.attributes.color.array[i*3] = c.r;
                        obj.geometry.attributes.color.array[i*3+1] = c.g;
                        obj.geometry.attributes.color.array[i*3+2] = c.b;
                    }
                }
                obj.geometry.attributes.color.needsUpdate = true;
            }
        });
        break;
    }

    mymmap.requestRender();
}

</script> 
</body> 
</html>
