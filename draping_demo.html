<html> 
<head> 
<title>My first Three.js app</title>


<style>
#layerSelection {
border-radius:5px;
background-color:#cccccc;
padding: 10px;
position:absolute;
left: 20px;
width: 170px;
font-family: "Arial";
}

</style>

</head>
<body>
<div id="container"></div>
<script src="thirdparty/three.js/build/three.js"></script> 
<script src="thirdparty/three.js/examples/js/controls/TrackballControls.js"></script>
<script src="thirdparty/three.js/examples/js/Detector.js"></script>
<script src="thirdparty/three.js/examples/js/libs/stats.min.js"></script>
<script src="thirdparty/three.js/examples/js/shaders/CopyShader.js"></script>
<script src="thirdparty/three.js/examples/js/shaders/SSAOShader.js"></script>
<script src="thirdparty/three.js/examples/js/shaders/BokehShader.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/EffectComposer.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/MaskPass.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/RenderPass.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/ShaderPass.js"></script>
<script src="thirdparty/three.js/examples/js/postprocessing/BokehPass.js"></script>
<script src="thirdparty/three.js/examples/fonts/helvetiker_regular.typeface.js"></script>
<script src="thirdparty/three.js/src/extras/GeometryUtils.js"></script>
<script src="thirdparty/three.js/examples/js/ShaderTerrain.js"></script>
<script src="thirdparty/proj4-src.js"></script>
<script src="thirdparty/proj4-srs.js"></script>
<script src="thirdparty/poly2tri.js"></script>
<script src="thirdparty/poly2tri.js"></script>
<script src="thirdparty/clipper.js"></script>
<script src="thirdparty/jquery-2.1.1.js"></script>
<script src="js/ShaderDraping.js"></script>
<script src="js/Terrain.js"></script>
<script src="js/WfsLayer.js"></script>
<script src="js/Tiler.js"></script>
<script src="js/TileLoader.js"></script>
<script src="js/Tile.js"></script>
<script src="js/QuadNode.js"></script>
<script src="js/QuadTree.js"></script>
<script>
inRender = false;
var quadtree;

init();

function refine( rings ){
    var fineRings = [];
    rings.forEach( function(ring){
        var lastPoint;
        var r = [];
        ring.forEach( function(point){
            if (lastPoint){
                r.push({x:(point.x+lastPoint.x)*.5, y:(point.y+lastPoint.y)*.5});
            }
            r.push(point);
            lastPoint = point;
        }); 
        r.push({x:(r[0].x+lastPoint.x)*.5, y:(r[0].y+lastPoint.y)*.5});
        fineRings.push(r);
    });
    return fineRings;
}

function intersects( point, bbox ){
    return point.x >= bbox[0] && point.y >= bbox[1]
        && point.x <= bbox[2] && point.y <= bbox[3];
}

// with line [{x1,y1},{x2,y2}]
// return [xmin,ymin, xmax, ymax]
function bbox( line ){
    return [Math.min(line[0].x, line[1].x),
            Math.min(line[0].y, line[1].y),
            Math.max(line[0].x, line[1].x),
            Math.max(line[0].y, line[1].y)];
}



// the poly should be clipped by grid before calling
function grid(poly, polyBbox, gridCenter, gridSize, gridNbDiv){
    var EPSILON = 1e-12;
    // ray tracing along x
    var y0 = gridCenter.y - 0.5*gridSize;
    var x0 = gridCenter.x - 0.5*gridSize;
    var stepSize = gridSize/gridNbDiv;
    var bottomIdx = Math.ceil( (polyBbox[1]-y0) / stepSize); 
    var topIdx = Math.floor( (polyBbox[3]-y0) / stepSize ); 
    if ( bottomIdx < 0 || topIdx > gridNbDiv ) throw 'bug';
    var points = [];
    //var iter = 100;
    var allInter = [];
    for ( var iy=bottomIdx; iy<=topIdx; iy++ ) {
        //console.log("y ", iy-bottomIdx+1, '/',topIdx-bottomIdx);
        var y = y0 + iy*stepSize;
        // find all intersections with this ray
        var intersections = [];//{ringIdx,segmentIdx,alpha, x, y}
        for (var r=0; r<poly.length; r++) {
            //console.log('ring ', r+1, '/',poly.length);
            var hit = 0;
            for (var p=1; p<=poly[r].length; p++) {
                //console.log('segment ', p, '/',poly[r].length-1);
                var segment = [ poly[r][p-1], poly[r][p%poly[r].length] ];
                //console.log( 'segment',segment, p-1, p%poly[r].length );
                var ySpan = segment[1].y - segment[0].y;
                //if (! --iter) throw 'here';
                //console.log( 'ySpan', ySpan, segment[0].y, y , segment[1].y);
                if ( Math.abs(ySpan) > EPSILON ) { // parralel to ray otherwise
                    var alpha =  (y - segment[0].y)/ySpan;
                    //console.log( 'alpha ', alpha );
                    if ( alpha >=0 && alpha <= 1){ // 
                        var x = segment[0].x + alpha * ( segment[1].x - segment[0].x );
                        intersections.push({
                                ringIdx:r, 
                                segmentIdx:p-1, 
                                alpha:alpha, 
                                x:x,
                                y:y
                                });
                        hit++;
                        if ( alpha == 1 &&
                           ( segment[0].y - y )*(  poly[r][(p+1)%poly[r].length].y - y ) < 0 ) { 
                            // decide if the raw crosses or touches
                            // the collision will also be detected by next segment test, 
                            // we keep it only if the ray does not cross the line
                            // i.e. the ray enters and exist at this point
                            intersections.pop();
                            --hit;
                            console.log('removed dupe at ',x,y)
                        }
                        //console.log('hit');
                    }
                }
                else if ( Math.abs(segment[0].y - y) < EPSILON) { // parallel to ray
                    // we have an intersection before and after
                    // for external ring we skip them
                    ++p;
                    intersections.pop();
                    --hit;

                }
            }
            //console.log ('ring ', r, 'hit ', hit);
            if ( hit%2 ) throw 'bug';
        }

        allInter.push.apply(allInter, intersections);

        intersections.sort(function(a,b){return a.x - b.x;});

        for ( var i = 1; i < intersections.length; i+=2 ) {
            //console.log('inter ', i+1, '/',intersections.length);
            var leftIdx = Math.ceil( (intersections[i-1].x-x0) / stepSize); 
            var rightIdx = Math.floor( (intersections[i].x-x0) / stepSize ); 
            //console.log('xIdx', leftIdx,rightIdx, intersections[i-1].x, intersections[i].x );
            for ( var ix = leftIdx; ix<=rightIdx; ix++ ){
                var x = x0 + ix*stepSize;
                //console.log(x,intersections[i-1].x,y);
                if (Math.abs(x - intersections[i-1].x) > EPSILON && Math.abs(x - intersections[i].x) > EPSILON){ // avoid point on line
                    points.push({x:x, y:y});
                }
            }
        }
    }

    // sort intersections by ring, reverse segments and reverse alpha
    allInter.sort( function( a, b ) {
        //
        if ( a.ringIdx == b.ringIdx) {
            if ( a.segmentIdx == b.segmentIdx ) {
                return b.alpha - a.alpha;
            }
            return b.segmentIdx - a.segmentIdx;
        }
        return a.ringIdx - b.ringIdx;

    });

    allInter.forEach( function(inter) {
        if ( inter.alpha > 100*EPSILON && inter.alpha < 1 - 100*EPSILON ){
            poly[inter.ringIdx].splice( inter.segmentIdx+1, 0, {x:inter.x, y:inter.y});
        }
    });

    // add intersections with x rays
    poly.forEach( function( ring ) {
        for (var p=1; p <= ring.length; p++) {
            var segment = [ ring[p-1], ring[p%ring.length] ];
            var startIdx =  (segment[0].x-x0) / stepSize; 
            var endIdx = (segment[1].x-x0) / stepSize;
            if ( startIdx < endIdx ) {
                var leftIdx = Math.floor(startIdx);
                var rightIdx = Math.ceil(endIdx);
                for ( i = rightIdx-1; i >= leftIdx+1; i-- ){
                    var x = x0 + i*stepSize;
                    var alpha =  (x - segment[0].x)/(segment[1].x-segment[0].x);
                    ring.splice(p, 0, {x:x ,y:segment[0].y + alpha * ( segment[1].y - segment[0].y )});
                }
            }
            else {
                var leftIdx = Math.floor(endIdx);
                var rightIdx = Math.ceil(startIdx);
                for ( i = leftIdx+1; i < rightIdx; i++ ){
                    var x = x0 + i*stepSize;
                    var alpha =  (x - segment[0].x)/(segment[1].x-segment[0].x);
                    ring.splice(p, 0, {x:x ,y:segment[0].y + alpha * ( segment[1].y - segment[0].y )});
                }
            }
        }
    });

    return points;
}

// intersects a grid {bbox, stepSize} and a line [{x1,y1},{x2,y2}]
// returns 3 lists {xIndexes, yIndexes, lineInetrpolations}
//
// scale + offset to have bbox as integers
// clip of line bbox by grid bbox
// all x and y in the intersection are intersected
// intersections in x for:
//      xStart + alpha*(xEnd-Xstart) = xGridOrig + dx*i
//      alpha =  (xGridOrig + dx*i - xStart)/(xEnd-Xstart)
// same in y, 
// then sort

function init() {
    window.addEventListener( 'resize', onWindowResize, false );
    document.addEventListener( 'mousedown', onDocumentMouseDown, false );

    // camera
    {
        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 100000 );
        camera.position.z = 200;
    }

    // scene
    {
        scene = new THREE.Scene();

        var gridSize = 100;
        var nbDiv = 20;
        var gridCenter = new THREE.Vector3(0,0,0);

        if (0)
        {
            var geom = new THREE.PlaneGeometry(gridSize, gridSize, nbDiv, nbDiv);
            var mesh = new THREE.Mesh(geom, 
                new THREE.MeshBasicMaterial( { color:0xffffff, wireframe:true } ));
            mesh.position = gridCenter;
            scene.add(mesh);        
        }

        {
            var geom = new THREE.Geometry();
            var rings = [[
                    {x:-35,y:-45},
                    {x:25,y:-25},
                    {x:22,y:2},
                    {x:25,y:25},
                    {x:-25,y:25} ]
                    ,
                    [
                    {x:-9,y:9},
                    {x:9,y:9},
                    {x:9,y:-9},
                    {x:-9,y:-9} ]
            ];
            var polyBbox = [-35, -45, 25, 25];


            // add points to rings and move them so they are not aligned

            try {
                console.log('before ', rings[0].length);
                var points = grid( rings, polyBbox, gridCenter, gridSize, nbDiv );
                console.log('after ', rings[0].length);

                {
                    rings.forEach(function(r) {
                        var g = new THREE.Geometry();
                        r.forEach(function(p) {
                            g.vertices.push(new THREE.Vector3(p.x, p.y, 0));
                        });
                        g.vertices.push(new THREE.Vector3(r[0].x, r[0].y, 0));

                        scene.add( new THREE.Line( g, 
                                          new THREE.LineBasicMaterial({ 
                                              color:0x00ff00, 
                                              linewidth:2 } ) ) );
                    });
                }
                {
                    var g = new THREE.Geometry();
                    points.forEach(function(p) {
                        g.vertices.push(new THREE.Vector3(p.x, p.y, 1));
                    });
                    var material = new THREE.ParticleBasicMaterial({ color: 0xFFFFFF, size: 1 });
                    scene.add( new THREE.ParticleSystem( g, material ) );
                }
                {
                    var g = new THREE.Geometry();
                    rings.forEach(function(r) {
                        r.forEach(function(p) {
                            g.vertices.push(new THREE.Vector3(p.x, p.y, 1));
                        });
                    });
                    var material = new THREE.ParticleBasicMaterial({ color: 0xff0000, size: 3 });
                    scene.add( new THREE.ParticleSystem( g, material ) );
                }

                var swctx = new poly2tri.SweepContext(rings[0]);
                for (var r=1; r<rings.length; r++) {
                    if (rings[r].length) swctx.addHole(rings[r]);
                }
                points.forEach(function(p){ swctx.addPoint(p); });
                swctx.triangulate();

                var triangles = swctx.getTriangles();
                var i = geom.vertices.length;
                triangles.forEach(function(t) {
                    t.getPoints().forEach(function(p) {
                        geom.vertices.push(new THREE.Vector3(p.x, p.y, 0));
                    });
                    geom.faces.push( new THREE.Face3(i, i+1, i+2) );
                    i += 3;
                });

                var mesh = new THREE.Mesh(geom, 
                    new THREE.MeshBasicMaterial( { color:0xff0000, wireframe:true } ));
                scene.add(mesh);        
            }
            catch (e) { 
                console.log(e);
            }

        }




        // lights
        {
            //light = new THREE.PointLight( 0xdddddd );
            light = new THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 2, 1 );
            light.position.set( 1000, 1000, 1000 );

            light.castShadow = true;
            light.shadowCameraVisible = true;
            light.shadowCameraNear = 1000;
            light.shadowCameraFar = 2000;
            light.shadowCameraFov = 20;
            light.shadowDarkness = 0.5;
            light.shadowMapWidth = 1024;
            light.shadowMapHeight = 512;

            scene.add( light );
            scene.add( new THREE.SpotLightHelper( light, 5 ) );

            alight = new THREE.AmbientLight( 0xdddddd );
            scene.add( alight );

        }

    }

    // renderer
    {
        renderer = new THREE.WebGLRenderer( { antialias: false } );
        renderer.setClearColor( 0x222222, 1 );
        renderer.setSize( window.innerWidth, window.innerHeight );

        // composer and effects
        {
            composer = new THREE.EffectComposer( renderer );
            composer.addPass( new THREE.RenderPass( scene, camera ) );
        }
    }

    // stats
    {
        container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );
        container.style.position = 'absolute';
        container.style.top = '0px';
        container.style.zIndex = -1;

        //var treeView = document.getElementById( 'myTreeView' );
        //treeView.style.top = '0px';
        //treeView.style.zIndex = 2;

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '150px';
        stats.domElement.style.zIndex = 100;
        container.appendChild( stats.domElement );
    }

    // first render to avoid blank screen before interaction
    render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
    render();
}

function render() {
    if (inRender) {
        // callback here, but a render is already in progress
        return;
    }
    inRender = true;
    scene.updateMatrixWorld();
    scene.traverse( function ( object ) {
        if ( object instanceof QuadTree ) {
            object.update( camera );
        }
    } );


    renderer.render( scene, camera );
    composer.render()
    stats.update();

    // load missing tiles
    TileLoader.instance().load( render );
    inRender = false;
}

function onDocumentMouseDown( event ) {
    event.preventDefault();

    var objects = [];
    scene.traverse( function(obj) {
        if ( obj.userData && obj.userData.faceGidMap ) {
            objects.push( obj );
        }
    });

    // WATCHOUT! the position must be relative to the canvas

    var vector = new THREE.Vector3( ( (event.clientX - container.offsetLeft) / window.innerWidth ) * 2 - 1, 
                                  - ( (event.clientY - container.offsetTop) / window.innerHeight ) * 2 + 1, 0.5 );
    var projector = new THREE.Projector();
    vector = projector.unprojectVector( vector, camera );
    console.log(vector.z*vector.x, vector.z*vector.y);

}
</script>
</body> 
</html>
